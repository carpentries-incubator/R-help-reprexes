---
title: "Minimal Reproducible Code"
teaching: 40
exercises: 35
---

::: questions
- # XXX updateme
- Why is it important to make a minimal code example?
- Which part of my code is causing the problem?
- Which parts of my code should I include in a minimal example?
- How can I tell whether a code snippet is reproducible or not?
- How can I make my code reproducible?
:::

::: objectives
- # XXX updateme
- Explain the value of a minimal code snippet.
- Identify the problem area of a script.
- Identify supporting parts of the code that are essential to include.
- Simplify a script down to a minimal code example.
- Evaluate whether a piece of code is reproducible as is or not. If not, identify what is missing.
- Edit a piece of code to make it reproducible
- Have a road map to follow to simplify your code.
- Describe the {reprex} package and its uses
:::

```{r echo = FALSE}
library(ggplot2)
library(dplyr)
rodents <- read.csv("data/surveys_complete_77_89.csv")
rodents <- rodents %>% filter(taxa == "Rodent")
```

Mickey is interested in understanding how kangaroo rat weights differ across species and sexes, so they create a quick visualization.

```{r}
ggplot(rodents, aes(x = species, fill = sex))+
  geom_bar()
```
Whoa, this is really overwhelming! Mickey forgot that the dataset includes data for a lot of different rodent species, not just kangaroo rats. Mickey is only interested in two kangaroo rat species: _Dipodomys ordii_ (Ord's kangaroo rat) and _Dipodomys spectabilis_ (Banner-tailed kangaroo rat). 

Mickey also notices that there are three categories for sex: F, M, and what looks like a blank field when there is no sex information available. For the purposes of comparing weights, Mickey wants to focus only rodents of known sex.

Mickey filters the data to include only the two focal species and only rodents whose sex is F or M.

```{r}
rodents_subset <- rodents %>%
  filter(species == c("ordii", "spectabilis"),
         sex == c("F", "M"))
```

Because these scientific names are long, Mickey also decides to add common names to the dataset. They start by creating a data frame with the common names, which they will then join to the `rodents_subset` dataset:

```{r}
## Adding common names
common_names <- data.frame(species = unique(rodents_subset$species), common_name = c("Ord's", "Banner-tailed"))
common_names
```

But looking at the `common names` dataset reveals a problem!

:::challenge
## Applying code first aid

1. Is this a syntax error or a semantic error? Explain why.
2. What "code first aid" steps might be appropriate here? Which ones are not helpful?
:::

Mickey realizes they need to re-order the names, so they try the code again. This time, it works and they join the common names to `rodents_subset`.

```{r}
common_names <- data.frame(species = sort(unique(rodents_subset$species)), common_name = c("Ord's", "Banner-Tailed"))
common_names
rodents_subset <- left_join(rodents_subset, common_names)
```

Before moving on to answering their research question about kangaroo rat weights, Mickey also wants to create a date column, since they realized that having the dates stored in three separate columns (`month`, `day`, and `year`) might be hard for future analysis. They want to use `{lubridate}` to parse the dates. But here, too, they run into trouble.

```{r error = T}
rodents_subset <- rodents_subset %>%
  mutate(date = lubridate(paste(year, month, day, sep = "-")))
```

:::instructor note
Because these are fairly simple errors, some learners (especially more advanced coders) may quickly "see" the solution and may need to be reminded to think through the exercise step by step and consider what steps could be helpful. Optionally, they can also be assigned the extra challenge exercise.
:::

:::challenge
## Applying code first aid, part 2

1. Is this a syntax error or a semantic error? Explain why.
2. What "code first aid" steps might be appropriate here? 
3. What would be your next step to fix this error, if you were Mickey?
:::

:::challenge
## Applying code first aid, part 2 (extra challenge)

Mickey tried several methods to create a date column. Here's one of them.
```{r error = T}
test <- rodents_subset %>%
  mutate(date = lubridate::as_date(paste(day, month, year)))
```

1. What type of error is this?
2. What do you learn from the warning message? Why do you think this code causes a warning message, rather than an error message?
3. Try some code first aid steps. What do you think happened here? How did you figure it out?
:::

Mickey reads some of the `{lubridate}` documentation and corrects their code so that the `date` column is created correctly.

```{r}
rodents_subset <- rodents_subset %>%
  mutate(date = lubridate::ymd(paste(year, month, day, sep = "-")))
```

Now that the dataset is cleaned, Mickey is ready to start learning about kangaroo rat weights!

They start by running a quick linear regression to predict `weight` based on `species` and `sex`.

```{r}
weight_model <- lm(weight ~ common_name + sex, data = rodents_subset)
summary(weight_model) 
```

The negative coefficient for `common_nameOrd's` tells Mickey that Ord's kangaroo rats are significantly less heavy than Banner-tailed kangaroo rats.

But something looks wrong with the coefficients for sex! Why is everything NA for `sexM`?

Mickey realizes that before creating a model, they should have re-visualized the dataset to make sure everything looked correct. They make a boxplot of kangaroo rat weights by species and sex, putting the species common names on the x axis and coloring by sex. They expect to see one box for each species-sex combination.

```{r}
rodents_subset %>%
  ggplot(aes(y = weight, x = common_name, fill = sex)) +
  geom_boxplot()
```

As the model made clear, Ord's kangaroo rats are significantly smaller than Banner-tailed kangaroo rats. But something is definitely wrong! The boxes are colored by sex, and it looks like all of the Banner-tailed kangaroo rats are male and all of the Ord's kangaroo rats are female. That can't be right! What are the chances of catching all one sex for two different species?

Mickey creates a two-way frequency table to see the raw numbers, and sure enough, there is only one sex for each species.
```{r}
table(rodents_subset$sex, rodents_subset$species)
```

What did the species-sex breakdown look like for the original dataset, before we subsetted it to just these two species?

```{r}
table(rodents$sex, rodents$species)
```

Not only were there originally males and females present from both _ordii_ and _spectabilis_, but the original numbers were way, way higher! It looks like somewhere along the way, Mickey lost a lot of observations.

[WORKING THROUGH CODE FIRST AID STEPS HERE]
Mickey is feeling overwhelmed and not sure where their code went wrong. They were able to fix the errors and warning messages that they encountered so far, but this one seems more complicated, and there has been no clear indication of what went wrong. They work their way through the code first aid steps

They decide to consult Remy's road map to figure out what to do next.

![](fig/roadmap.png)

Since code first aid was not enough to solve this problem, it looks like it's time to ask for help using a *reprex*.

# Making a reprex

## Simplify the code

When asking someone else for help, it is important to simplify your code as much as possible to make it easier for the helper to understand what is wrong. Simplifying code helps to reduce frustration and overwhelm when debugging an error in a complicated script. The more that we can make the process of helping easy and painless for the helper, the more likely that they will take the time to help.

Let's look at all the code that Mickey has written so far.

:::callout
Depending on how closely you have been following the lesson and which challenges you have attempted, your script may not look exactly like Mickey's. That's okay!
:::

```{r eval = F}
# Load packages and data
library(ggplot2)
library(dplyr)
rodents <- read.csv("data/surveys_complete_77_89.csv")

# XXX ADD PETER'S EPISODE CODE HERE

## Filter to only rodents
rodents <- rodents %>% filter(taxa == "Rodent")

# Visualize sex by species
ggplot(rodents, aes(x = species, fill = sex))+
  geom_bar()

# Subset to species and sexes of interest
rodents_subset <- rodents %>%
  filter(species == c("ordii", "spectabilis"),
         sex == c("F", "M"))

# Add common names
# common_names <- data.frame(species = unique(rodents_subset$species), common_name = c("Ord's", "Banner-tailed"))
# common_names # oops, this looks wrong!
common_names <- data.frame(species = sort(unique(rodents_subset$species)), common_name = c("Ord's", "Banner-Tailed"))
common_names
rodents_subset <- left_join(rodents_subset, common_names)

# Add a date column
# rodents_subset <- rodents_subset %>%
#   mutate(date = lubridate(paste(year, month, day, sep = "-"))) # that didn't work!

rodents_subset <- rodents_subset %>%
  mutate(date = lubridate::ymd(paste(year, month, day, sep = "-")))

# Predict weight by species and sex, and make a plot
weight_model <- lm(weight ~ common_name + sex, data = rodents_subset)
summary(weight_model) 
rodents_subset %>%
  ggplot(aes(y = weight, x = common_name, fill = sex)) +
  geom_boxplot() # wait, why does this look weird?

# Investigate
table(rodents_subset$sex, rodents_subset$species)
table(rodents$sex, rodents$species)
```

Wow, that's a lot! Mickey's code also contains explanatory comments (which are great, but they may or may not be relevant to the problem at hand), and where their code threw errors, they sometimes kept the old code, commented out, for future reference.

### Create a new script

To make the task of simplifying the code less overwhelming, let's create a separate script for our reprex. This will allow us to experiment with stripping down our code to its basic parts while keeping the original code intact.

Let's created and save a new, blank R script and give it a name, such as "reprex-script.R"

:::::::::::::::::::::::::::::::::::::callout
## Creating a new R script
There are several ways to make an R script
- File > New File > R Script
- Click the white square with a green plus sign at the top left corner of your RStudio window
- Use a keyboard shortcut: Cmd + Shift + N (on a Mac) or Ctrl + Shift + N (on Windows)
::::::::::::::::::::::::::::::::::::::::::: 

We're going to start by copying over all of our code, so we have an exact copy of the full analysis script.

```{r eval = F}
# Minimal reproducible example script
# Load packages and data
library(ggplot2)
library(dplyr)
rodents <- read.csv("data/surveys_complete_77_89.csv")

# XXX ADD PETER'S EPISODE CODE HERE

## Filter to only rodents
rodents <- rodents %>% filter(taxa == "Rodent")

# Visualize sex by species
ggplot(rodents, aes(x = species, fill = sex))+
  geom_bar()

# Subset to species and sexes of interest
rodents_subset <- rodents %>%
  filter(species == c("ordii", "spectabilis"),
         sex == c("F", "M"))

# Add common names
# common_names <- data.frame(species = unique(rodents_subset$species), common_name = c("Ord's", "Banner-tailed"))
# common_names # oops, this looks wrong!
common_names <- data.frame(species = sort(unique(rodents_subset$species)), common_name = c("Ord's", "Banner-Tailed"))
common_names
rodents_subset <- left_join(rodents_subset, common_names)

# Add a date column
# rodents_subset <- rodents_subset %>%
#   mutate(date = lubridate(paste(year, month, day, sep = "-"))) # that didn't work!

rodents_subset <- rodents_subset %>%
  mutate(date = lubridate::ymd(paste(year, month, day, sep = "-")))

# Predict weight by species and sex, and make a plot
weight_model <- lm(weight ~ common_name + sex, data = rodents_subset)
summary(weight_model) 
rodents_subset %>%
  ggplot(aes(y = weight, x = common_name, fill = sex)) +
  geom_boxplot() # wait, why does this look weird?

# Investigate
table(rodents_subset$sex, rodents_subset$species)
table(rodents$sex, rodents$species)
```

Now, we will follow a process: 
1. Identify the symptom of the problem.
2. Remove a piece of code to make the reprex more minimal.
3. Re-run the reprex to make sure the reduced code still demonstrates the problem.

In this case, the problem is that *we are missing rows (ordii males, spectabilis females, and also some ordii females and spectabilis males!) in `rodents_subset` that were present in `rodents` and should not have been removed!*

Let's start by identifying pieces of code that we can probably remove. A good start is to look for lines of code that did not create variables that we used later, or that added complexity to the analysis that is not relevant to the problem at hand.

We can certainly remove the broken code that we commented out earlier! Also, adding a date column is something we wanted to do to make future analyses easier, but it is not directly relevant to the current problem, since we haven't started working with `date` yet. Let's go ahead and remove those pieces of code. Now our script looks like this:

```{r eval = F}
# Minimal reproducible example script
# Load packages and data
library(ggplot2)
library(dplyr)
rodents <- read.csv("data/surveys_complete_77_89.csv")

# XXX ADD PETER'S EPISODE CODE HERE

## Filter to only rodents
rodents <- rodents %>% filter(taxa == "Rodent")

# Visualize sex by species
ggplot(rodents, aes(x = species, fill = sex))+
  geom_bar()

# Subset to species and sexes of interest
rodents_subset <- rodents %>%
  filter(species == c("ordii", "spectabilis"),
         sex == c("F", "M"))

# Add common names
common_names <- data.frame(species = sort(unique(rodents_subset$species)), common_name = c("Ord's", "Banner-Tailed"))
common_names
rodents_subset <- left_join(rodents_subset, common_names)

# Predict weight by species and sex, and make a plot
weight_model <- lm(weight ~ common_name + sex, data = rodents_subset)
summary(weight_model) 
rodents_subset %>%
  ggplot(aes(y = weight, x = common_name, fill = sex)) +
  geom_boxplot() # wait, why does this look weird?

# Investigate
table(rodents_subset$sex, rodents_subset$species)
table(rodents$sex, rodents$species)
```

When we run this code, we can confirm that it still demonstrates our problem. There are still many rows missing from `rodents_subset`.

We've made progress on minimizing our code, but we still have a ways to go. This script is still pretty long! Let's identify more pieces of code that we can remove.

:::::challenge
## Minimizing code

Which other lines of code can you remove to make this script more minimal? After removing each one, be sure to re-run the code to make sure that it still reproduces the error.
:::solution
- [Peter's episode code]
- Visualizing sex by species (ggplot) can be removed because it generates a plot but does not create any variables that are used later.
- Filtering to only rodents can be removed because later we filter to only two species in particular
- Adding common names can be removed because we didn't actually use those common names. This one is tricky because technically we did use the common names in the rodents_subset plot. But is that plot *really* necessary? We can still demonstrate the problem using the table() lines of code at the end. Also, we could still make the equivalent plot using the `species` column instead of the `common_name` column, and it would demonstrate the same thing!
- The weight model and the summary can be removed

A totally minimal script would look like this:
```{r eval = F}
# Minimal reproducible example script
# Load packages and data
library(ggplot2)
library(dplyr)
rodents <- read.csv("data/surveys_complete_77_89.csv")

# Subset to species and sexes of interest
rodents_subset <- rodents %>%
  filter(species == c("ordii", "spectabilis"),
         sex == c("F", "M"))

# Investigate
table(rodents_subset$sex, rodents_subset$species)
table(rodents$sex, rodents$species)
```
:::::

Great, now we have a totally minimal script!





However, we're not done yet. 

:::challenge
## The problem area is not enough

Let's suppose that Mickey has created the minimal problem area script shown above. They email this script to Remy so that Remy can help them debug the code.

Remy opens up the script and tries to run it on their computer, but it doesn't work.
- What do you think will happen when Remy tries to run the code from this reprex script?
- What do you think Mickey should do next to improve the minimal reproducible example?
:::

We haven't yet included enough code to allow a helper, such as Remy, to run the code on their own computer. If Remy tries to run the reprex script in its current state, they will encounter errors because they don't have access to the same R environment that Mickey does. 

### Include dependencies

R code consists primarily of **functions** and **variables**. In order to make our minimal examples truly _reproducible_, we have to give our helpers access to all the functions and variables that are necessary to run our code.

First, let's talk about **functions**. Functions in R typically come from packages. You can access them by loading the package into your environment. 

To make sure that your helper has access to the packages necessary to run your reprex, you will need to include calls to `library()` for whichever packages are used in the code. For example, if your code uses the function `lmer` from the `{lme4}` package, you would have to include `library(lme4)` at the top of your reprex script to make sure your helper has the `{lme4}` package loaded and can run your code.

::: callout
Some packages, such as `{base}` and `{stats}`, are loaded in R by default, so you might not have realized that a lot of functions, such as `dim`, `colSums`, `factor`, and `length` actually come from those packages!

You can see a complete list of the functions that come from the `{base}` and `{stats}` packages by running `library(help = "base")` or `library(help = "stats")`.
:::

Let's do this for our own reprex. We can start by identifying all the functions used, and then we can figure out where each function comes from to make sure that we tell our helper to load the right packages.

The first function used in our example is `ggplot()`, which comes from the package `{ggplot2}`. Therefore, we know we will need to add `library(ggplot2)` at the top of our script.

The function `geom_boxplot()` also comes from `{ggplot2}`. We also used the function `table()`. Running `?table` tells us that the `table` function comes from the package `{base}`, which is automatically installed and loaded when you use R--that means we don't need to include `library(base)` in our script.

Our reprex script now looks like this:

```{r}
# Mickey's reprex script

# Load necessary packages to run the code
library(ggplot2)

rodents_subset %>%
  ggplot(aes(y = weight, x = common_name, fill = sex)) +
  geom_boxplot() # wait, why does this look weird?

# Investigate
table(rodents_subset$sex, rodents_subset$species)
table(rodents$sex, rodents$species)
```

::::::::::::::::::::::::::::::::::::::::::: callout
## Installing vs. loading packages

But what if our helper doesn't have all of these packages installed? Won't the code not be reproducible?

Typically, we don't include `install.packages()` in our code for each of the packages that we include in the `library()` calls, because `install.packages()` is a one-time piece of code that doesn't need to be repeated every time the script is run. We assume that our helper will see `library(specialpackage)` and know that they need to go install "specialpackage" on their own.

Technically, this makes that part of the code not reproducible! But it's also much more "polite". Our helper might have their own way of managing package versions, and forcing them to install a package when they run our code risks messing up our workflow. It is a common convention to stick with `library()` and let them figure it out from there.
:::::::::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::: challenge
## Which packages are essential?

In each of the following code snippets, identify the necessary packages (or other code) to make the example reproducible.

- [Example (including an ambiguous function: `dplyr::select()` is a good one because it masks `plyr::select()`)]
- [Example where you have to look up which package a function comes from]
- [Example with a user-defined function that doesn't exist in any package]

This exercise should take about 10 minutes.
:::solution
FIXME
:::
:::::::::::::::::::::::::::::::::::::::::::

Including `library()` calls will definitely help Remy run the code. But this code still won't work as written because Remy does not have access to the same *objects*, also known as *variables*, that Mickey used in the code. 

The small piece of code that we copied from the main script into the reprex script came from the end of the script. Mickey had already done a lot of analyses before then, starting from the raw dataset that they read into R, and creating and modifying new objects along the way.

The code as written relies on two objects, `rodents_subset` and `rodents`, that Remy will not have access to if they try to run the code. That means that we've succeeded in making our example *minimal*, but it is not *reproducible*: it does not allow someone else to reproduce the problem!

Let's ask ourselves: where did each of these objects come from? We can add the code that created each of those objects.

```{r eval = F}
# Mickey's reprex script

# Load necessary packages to run the code
library(ggplot2)

# Code to create `rodents
rodents <- read.csv("data/surveys_complete_77_89.csv")

# Code to create `rodents_subset`

rodents_subset %>%
  ggplot(aes(y = weight, x = common_name, fill = sex)) +
  geom_boxplot() # wait, why does this look weird?

# Investigate
table(rodents_subset$sex, rodents_subset$species)
table(rodents$sex, rodents$species)
```

But that doesn't fix the problem either, because now Jordan doesn't have access to `krats`. Let's go back to where `krats` was created, on line 40:

```{r}
# Just kangaroo rats because this is what we are studying
krats <- rodents %>%
  filter(genus == "Dipodomys")
dim(krats) # okay, so that's a lot smaller, great.
glimpse(krats)
```

But there are several other places in the code where we modified `krats`, and we need to include those as well if we want our code to be truly reproducible. For example, on line 47, a date column was added, and on line 70 we removed unidentified k-rats. And even after including those, we would need to go back even farther, because the `rodents` object also isn't something that Jordan has access to! We called the raw data `rodents` after reading it in, and we also made several modifications, such as when we removed non-rodent taxa on line 35.
XXX This example would be better illustrated if we could actually show it breaking... like, if we think we've succeeded in tracing back far enough, and then it doesn't run because e.g. an essential column is missing/different.
XXX This is definitely too much detail... but I do want this section to at least partially feel like "aaaah information overload, too complicated!" because the point is to show how hard it is to trace every object backwards and convince them of the value of using minimal data.

::::::::::::::::::::::::::::::::::::::::::: challenge
## Identifying variables

For each of the following code snippets, identify all the variables used

- [Straightforward example]
- [Example where they use a built-in dataset but it contains a column that that dataset doesn't actually contain, i.e. because it's been modified previously. Might be good to use the `date` column that we put into `krats` for this]

This exercise should take about 5 minutes.
::: solution
TBH maybe we don't need this exercise at all, since we want to just redirect them to minimal data anyway?
:::
::::::::::::::::::::::::::::::::::::::::::: 

This process is confusing and difficult! If you keep tracing each variable back through your script, before you know it, you end up needing to include the entire script to give context, and then your code is no longer minimal.

We can make our lives easier if we realize that helpers don't always need the exact same variables and datasets that we were using, just reasonably good stand-ins. Let's think back to the last episode, where we talked about different ways to create minimal reproducible datasets. We can lean on those skills here to make our example reproducible and greatly reduce the amount of code that we need to include.

:::::::::::::::::::::::::::::::::::::::::::challenge
## Incorporating minimal datasets

What are some ways that you could use a minimal dataset to make this reprex better? What are the advantages and disadvantages of each approach?

This exercise should take about 5 minutes.
::: solution
Could provide the `control_spectab` file directly to Jordan, e.g. via email attachment. 
Advantages: less work, keeps the context, Jordan is a coworker so they probably understand it. 
Disadvantages: file might be large, relies on ability to email file, won't be able to use this method if you post the question online, file contains extra rows/columns that aren't actually necessary to this problem and might therefore be confusing.
  
Could create a new dataset from scratch. 
Advantages:
Disadvantages:
  
Could take a minimal subset of the `control_spectab` data and use `dput` or similar to include it directly
Advantages:
Disadvantages:

Could use a built-in dataset from R
Advantages:
Disadvantages:
:::
::::::::::::::::::::::::::::::::::::::::::: 

You decide that the easiest way to approach this particular problem would be to use a sample dataset to reproduce the problem.

Let's think about how to create a sample dataset that will accurately reproduce the problem.
What columns are needed to create `prop_spectab`, and what do we know about those columns?

```{r}
head(control_spectab)
length(unique(control_spectab$year)) # 13 years
length(unique(control_spectab$species_id)) # three species
length(unique(control_spectab$plot_type)) # two plot types
```

Looks like we use `year`, which is numeric, and `plot_type` and `species_id`, which are both character types but have discrete levels like a factor. We have data from 13 years across two plot types, and there are three species that might occur.

Let's create some vectors. I'm only going to use four years here because 13 seems a little excessive.

I'm going to arbitrarily decide how many species records are present for each year, assign every other row to treatment or control, and randomly select species for each row.
```{r}
years <- 1:4
species <- c("Species A", "Species B", "Species C")
plots <- c("Control", "Treatment")

total_records_per_year <- c(10, 12, 3, 30) # I chose these arbitrarily 
total_rows <- sum(total_records_per_year) # how many total rows will we have?

# Create the fake data using `rep()` and `sample()`.
minimal_data <- data.frame(year = rep(years, times = total_records_per_year),
                      plot_type = rep(plots, length.out = total_rows),
                      species_id = sample(species, size = total_rows, replace = TRUE))
```

We can go ahead and paste that into our reprex script. 

```{r}
# Provide a minimal dataset
years <- 1:4
species <- c("Species A", "Species B", "Species C")
plots <- c("Control", "Treatment")

total_records_per_year <- c(10, 12, 3, 30) # I chose these arbitrarily 
total_rows <- sum(total_records_per_year) # how many total rows will we have?

# Create the fake data using `rep()` and `sample()`.
minimal_data <- data.frame(year = rep(years, times = total_records_per_year),
                      plot_type = rep(plots, length.out = total_rows),
                      species_id = sample(species, size = total_rows, replace = TRUE))
```

And finally, let's change our code to use `minimal_data` instead of `control_spectab`. (While we're at it, let's remove the piece of code that creates `control_spectab`--including a minimal dataset directly means that we don't need that code.)

Let's calculate the proportion of Species A caught, instead of spectabilis.

```{r}
# Calculate proportion of Species A caught
head(minimal_data)
prop_speciesA <- minimal_data %>%
  group_by(year, plot_type, species_id) %>%
  summarize(total_count = n(), .groups = "drop") %>%
  mutate(prop = total_count/sum(total_count)) %>%
  dplyr::filter(species_id == "Species A") # keep only Species A
```

And now let's check to make sure that the code actually reproduces our problem. Remember, the problem was that the proportions of Species A caught seemed to be way too low based on what we knew about the frequency of occurrence of each k-rat species.

When we created our sample data, we randomly allocated species A, B, and C to each row. Even after accounting for the stratification of the years and plot types, we would expect the proportion of Species A caught to be somewhere vaguely around 0.33 in each plot type and year. If we've reproduced our problem correctly, we would see values much lower than 0.33.

```{r}
head(prop_speciesA)
```

Indeed, those proportions look way too low! 3%, 1%... that's an order of magnitude off from what we expect to see here. I think we have successfully reproduced the problem using a minimal dataset. To make things extra easy for Jordan, let's add some comments in the script to point out the problem.

```{r}
# This script will contain my minimal reproducible example.
# Created by Mishka on 2024-12-17

# Load packages needed for the analysis
library(dplyr)

# Provide a minimal dataset
years <- 1:4
species <- c("Species A", "Species B", "Species C")
plots <- c("Control", "Treatment")

total_records_per_year <- c(10, 12, 3, 30) # I chose these arbitrarily 
total_rows <- sum(total_records_per_year) # how many total rows will we have?

# Create the fake data using `rep()` and `sample()`.
minimal_data <- data.frame(year = rep(years, times = total_records_per_year),
                      plot_type = rep(plots, length.out = total_rows),
                      species_id = sample(species, size = total_rows, replace = TRUE)) # Because I assigned the species randomly, we should expect Species A to occur *roughly* 33% of the time.

# Calculate proportion of Species A caught
head(minimal_data)
prop_speciesA <- minimal_data %>%
  group_by(year, plot_type, species_id) %>%
  summarize(total_count = n(), .groups = "drop") %>%
  mutate(prop = total_count/sum(total_count)) %>%
  dplyr::filter(species_id == "Species A") # keep only Species A

head(prop_speciesA) # Species A only occurs 1-3% of the time in each plot type in each year. Why is this off by an order of magnitude? (This is the same problem I was seeing in my real data--the occurrence proportions were way, way too small.)
```

### Step 3. Simplify

We're almost done! Now we have code that runs because it includes the necessary `library()` calls and makes use of a minimal dataset that still allows us to showcase the problem. Our script is almost ready to send to Jordan. 

One last thing we can check is whether there are any other places where we can trim down the minimal example even more to eliminate distractions.

Often, analysis code contains exploratory steps or other analyses that don't directly relate to the problem, such as calls to `head()`, `View()`, `str()`, or similar functions. (Exception: if you're using these directly to show things like dimension changes that help to illustrate the problem).

Some other common examples are exploratory analyses, or extra formatting added to plots that doesn't change their interpretation.

:::callout
When cutting extra lines of code, we have to be careful not to remove anything that would cause the code to no longer reproduce our problem. In general, it's a good idea to comment out the line you think is extraneous, re-run the code, and check that the focal problem persists before removing it entirely.
:::

In our case, the code looks pretty minimal. We do have a call to `head()` at the end, but that's being used to clearly demonstrate the problem, so it should be left in. Trimming down the minimal dataset any further, for example by removing `plot_type` or `year`, would involve changing the analysis code and possibly not reproducing the problem anymore.

---
XXX @XOR @PL: I wish I had picked an example that had some extraneous parts to take out, such as a ggplot call with really long code. Would love to include that. Since I didn't, I think I can take out this entire section of the roadmap, or add it as a bonus exercise that gives a completely different example with a lot of extraneous things to remove. Another option would be to add some fluff to the original code so that we can remove that fluff now. Thoughts/preferences?
---

Great work! We've created a minimal reproducible example. In the next episode, we'll learn about `{reprex}`, a package that can help us double-check that our example is reproducible by running it in a clean environment. (As an added bonus, `{reprex}` will format our example nicely so it's easy to post to places like Slack, GitHub, and StackOverflow.)

More on that soon. For now, let's review the road map that we just practiced.

## Road map review
### Step 0. Create a separate script
  - It helps to have a separate place to work on your minimal code snippet.
  
### Step 1. Identify the problem area
  - Which part of the code is causing the problem? Move it over to the reprex script so we can focus on it.
  
### Step 2. Identify dependencies
  - Make sure that helpers have access to all the functions they'll need to run your code snippet.
  - Make sure helpers can access the variables they'll need to run the code, or reasonable stand-ins.
  
### Step 3. Simplify
  - Remove any extra code that isn't absolutely necessary to demonstrate your problem.

:::::::::::::::::::::::::::::::::::::::::::challenge
## Reflection

Let's take a moment to reflect on this process.

- What's one thing you learned in this episode? An insight; a new skill; a process?

- What is one thing you're still confused about? What questions do you have?

This exercise should take about 5 minutes.
::::::::::::::::::::::::::::::::::::::::::: 


# XXX maybe this story should end with Mishka solving their own problem.


### run an ANOVA or something
XXX Note: There's more to the analysis, and I only managed to walk through one example of an error. Is this example juicy enough? Should we just discard the rest of the analysis?
XXX Note: I actually think the analysis here is wrong and might need to be re-worked--would need to do pairwise comparisons.

#### MODELING ####
counts_mod <- lm(count_per_day ~ plot_type + species_id, data = counts_per_day)
summary(counts_mod)

# with interaction term:
counts_mod_interact <- lm(count_per_day ~ plot_type*species_id, data = counts_per_day)
summary(counts_mod_interact)

summary(counts_mod)
summary(counts_mod_interact)








:::::::::::::::::::::::::::::::::::::callout
## Stepping through code, line by line

Placing your cursor on a line of code and using the keyboard shortcut Cmd + Enter (Mac) or Ctrl + Enter (Windows) will run that line of code *and* it will automatically advance your cursor to the next line. This makes it easy to "step through" your code without having to click or highlight.
::::::::::::::::::::::::::::::::::::::::::: 


::::::::::::::::::::::::::::::::::::::::::: callout
## Computational reproducibility

Every object should be able to map back to either a file, a built-in dataset in R, or another intermediate step. If you found any variables where you weren't able to answer the "Where did this come from?" question, then that's a problem! Did you build a script that mistakenly relied on an object that was in your environment but was never properly defined?

Mapping exercises like this can be a great way to check whether entire script is reproducible. Reproducibility is important in more cases than just debugging! More and more journals are requiring full analysis code to be posted, and if that code isn't reproducible, it will severely hamper other researchers' efforts to confirm and expand on what you've done.

Various packages can help you keep track of your code and make it more reproducible. Check out the [`{targets}`](https://books.ropensci.org/targets/) and [`{renv}`](https://rstudio.github.io/renv/articles/renv.html) packages in particular if you're interested in learning more.
::::::::::::::::::::::::::::::::::::::::::: 
